// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float> _p;
StructuredBuffer<float> _div;

RWStructuredBuffer<float> _u;
RWStructuredBuffer<float> _v;

int _N;

int IX(int i, int j)
{
	return i + (_N + 2) * j;
}

void SetBnd(int b, RWStructuredBuffer<float> x)
{
	/*for (int i = 1; i < _N + 1; i++)
	{
		x[IX(0, i)] = b == 1 ? -x[IX(1, i)] : x[IX(1, i)];
		x[IX(_N + 1, i)] = b == 1 ? -x[IX(_N, i)] : x[IX(_N, i)];
		x[IX(i, 0)] = b == 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
		x[IX(i, _N + 1)] = b == 2 ? -x[IX(i, _N)] : x[IX(i, _N)];
	}
	x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
	x[IX(0, _N + 1)] = 0.5 * (x[IX(1, _N + 1)] + x[IX(0, _N)]);
	x[IX(_N + 1, 0)] = 0.5 * (x[IX(_N, 0)] + x[IX(_N + 1, 1)]);
	x[IX(_N + 1, _N + 1)] = 0.5 * (x[IX(_N, _N + 1)] + x[IX(_N + 1, _N)]);*/
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	//if (id.x < 1 || id.x > _N || id.y < 1 || id.y > _N) return;

	float h;
	h = 1. / (float) _N;
	float div = -0.5 * h * (_u[IX(id.x + 1, id.y)] - _u[IX(id.x - 1, id.y)] + _v[IX(id.x, id.y + 1)] - _v[IX(id.x, id.y - 1)]);
	for (int i = 0; i < 50; i++) {
		_p[IX(id.x, id.y)] = (div + _p[IX(id.x - 1, id.y)] + _p[IX(id.x + 1, id.y)] + _p[IX(id.x, id.y - 1)] + _p[IX(id.x, id.y + 1)]) / 4.;
		AllMemoryBarrier();
	}
	_u[IX(id.x, id.y)] -= 0.5 * (_p[IX(id.x + 1, id.y)] - _p[IX(id.x - 1, id.y)]) / h;
	_v[IX(id.x, id.y)] -= 0.5 * (_p[IX(id.x, id.y + 1)] - _p[IX(id.x, id.y - 1)]) / h;
}
